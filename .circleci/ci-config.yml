version: 2.1

# ============================================================================
# CircleCI Pipeline for .NET Web API
# Comprehensive CI/CD pipeline with security scanning, code quality, and deployment
# ============================================================================

# Environment variables
environment: &default_environment
  DOTNET_VERSION: "8.0.x"
  IMAGE_NAME: "dotnet-webapi"
  REGISTRY_PATH: "hkjctest.jfrog.io/alley-oop-container/circleci"
  SONAR_PROJECT_KEY: "thiago-tota_gha-dotnet-webapi"
  SONAR_ORGANIZATION: "thiago-tota"

# Orbs for extended functionality
orbs:
  docker: circleci/docker@2.8.2
  snyk: snyk/snyk@2.3.0
  artifactory: circleci/artifactory@1.0.0
  sonarcloud: sonarsource/sonarcloud@3.0.0

# Executors
executors:
  dotnet-executor:
    docker:
      - image: mcr.microsoft.com/dotnet/sdk:8.0
    environment:
      <<: *default_environment
  
  ubuntu-docker:
    docker:
      - image: cimg/base:stable
    environment:
      <<: *default_environment

# Jobs
jobs:
  # Build and Test
  build-and-test:
    executor: dotnet-executor
    steps:
      - checkout
      
      - run:
          name: Display .NET Version
          command: dotnet --version
      
      - run:
          name: Restore Dependencies
          command: dotnet restore
      
      - run:
          name: Build Solution
          command: dotnet build --configuration Release --no-restore
      
      - run:
          name: Run Unit Tests
          command: |
            dotnet test Dotnet.Webapi.Tests/Dotnet.Webapi.Tests.csproj \
              --configuration Release \
              --no-build \
              --verbosity normal \
              --logger trx \
              --results-directory TestResults
      
      - store_test_results:
          path: TestResults
      
      - store_artifacts:
          path: TestResults
          destination: test-results
      
      - persist_to_workspace:
          root: .
          paths:
            - Dotnet.Webapi/bin/Release/net8.0
            - Dotnet.Webapi/Dockerfile
            - TestResults

  # Snyk Security Scan
  snyk-security-scan:
    executor: dotnet-executor
    steps:
      - checkout
      
      - attach_workspace:
          at: .
      
      - run:
          name: Restore Dependencies
          command: dotnet restore
      
      - run:
          name: Build for Snyk Analysis
          command: dotnet build --configuration Release --no-restore
      
      - run:
          name: Install Snyk CLI
          command: |
            # Download and install Snyk CLI manually (no sudo required)
            curl -Lo /tmp/snyk https://github.com/snyk/cli/releases/latest/download/snyk-linux
            chmod +x /tmp/snyk
            echo 'export PATH="/tmp:$PATH"' >> $BASH_ENV
            
            # Verify installation
            /tmp/snyk --version
      
      - run:
          name: Authenticate Snyk
          command: /tmp/snyk auth $SNYK_TOKEN
      
      - run:
          name: Run Snyk Security Scan
          command: |
            echo "Running Snyk security scan..."
            
            # Scan for vulnerabilities
            /tmp/snyk test \
              --severity-threshold=high \
              --sarif-file-output=snyk.sarif \
              --json-file-output=snyk-results.json || true
            
            echo "Snyk security scan completed"
      
      - run:
          name: Create Snyk Security Summary
          command: |
            echo "## ðŸ›¡ï¸ Snyk Security Scan Results" > snyk-summary.md
            echo "" >> snyk-summary.md
            
            if [ -f snyk-results.json ]; then
              # Parse JSON results and create summary
              VULNERABILITIES=$(cat snyk-results.json | jq -r '.vulnerabilities | length' 2>/dev/null || echo "0")
              HIGH_VULNS=$(cat snyk-results.json | jq -r '[.vulnerabilities[] | select(.severity == "high")] | length' 2>/dev/null || echo "0")
              MEDIUM_VULNS=$(cat snyk-results.json | jq -r '[.vulnerabilities[] | select(.severity == "medium")] | length' 2>/dev/null || echo "0")
              LOW_VULNS=$(cat snyk-results.json | jq -r '[.vulnerabilities[] | select(.severity == "low")] | length' 2>/dev/null || echo "0")
              
              echo "### Code Vulnerability Summary" >> snyk-summary.md
              echo "| Severity | Count |" >> snyk-summary.md
              echo "|----------|-------|" >> snyk-summary.md
              echo "| ðŸ”´ High | $HIGH_VULNS |" >> snyk-summary.md
              echo "| ðŸŸ¡ Medium | $MEDIUM_VULNS |" >> snyk-summary.md
              echo "| ðŸ”µ Low | $LOW_VULNS |" >> snyk-summary.md
              echo "| **Total** | **$VULNERABILITIES** |" >> snyk-summary.md
              echo "" >> snyk-summary.md
              
              if [ "$VULNERABILITIES" -gt "0" ]; then
                echo "âš ï¸ **Action Required**: $VULNERABILITIES vulnerabilities found in dependencies" >> snyk-summary.md
              else
                echo "âœ… **No vulnerabilities found** - All dependencies are secure!" >> snyk-summary.md
              fi
            else
              echo "âŒ **Scan Failed**: Unable to generate vulnerability report" >> snyk-summary.md
            fi
      
      - store_artifacts:
          path: snyk.sarif
          destination: security-reports/snyk.sarif
      
      - store_artifacts:
          path: snyk-results.json
          destination: security-reports/snyk-results.json
      
      - store_artifacts:
          path: snyk-summary.md
          destination: security-reports/snyk-summary.md

  # SonarQube Code Quality Scan
  sonarqube-scan:
    executor: dotnet-executor
    steps:
      - checkout
      
      - attach_workspace:
          at: .
      
      - run:
          name: Install Required Tools
          command: |
            # Update package list and install unzip (required by SonarCloud orb)
            apt-get update
            apt-get install -y unzip
      
      - run:
          name: Restore Dependencies
          command: dotnet restore
      
      - run:
          name: Build and Test with Coverage
          command: |
            dotnet build --configuration Release --no-restore
            dotnet test Dotnet.Webapi.Tests/Dotnet.Webapi.Tests.csproj \
              --configuration Release \
              --no-build \
              --logger trx \
              --results-directory TestResults \
              --collect:"XPlat Code Coverage" \
              --settings coverlet.runsettings
      
      - run:
          name: Create SonarCloud Configuration
          command: |
            echo "sonar.projectKey=${SONAR_PROJECT_KEY}" > sonar-project.properties
            echo "sonar.organization=${SONAR_ORGANIZATION}" >> sonar-project.properties
            echo "sonar.host.url=https://sonarcloud.io" >> sonar-project.properties
            echo "sonar.sources=Dotnet.Webapi" >> sonar-project.properties
            echo "sonar.tests=Dotnet.Webapi.Tests" >> sonar-project.properties
            echo "sonar.cs.dotcover.reportsPaths=**/TestResults/**/coverage.cobertura.xml" >> sonar-project.properties
            echo "sonar.cs.vstest.reportsPaths=**/TestResults/*.trx" >> sonar-project.properties
            cat sonar-project.properties
      
      - sonarcloud/scan:
          sonar_token_variable_name: SONAR_TOKEN
          cache_version: 1
      
      - run:
          name: Create SonarQube Summary
          command: |
            echo "## ðŸ“Š SonarQube Code Quality Analysis" > sonarqube-summary.md
            echo "" >> sonarqube-summary.md
            echo "### Analysis Details" >> sonarqube-summary.md
            echo "- **Project**: ${SONAR_PROJECT_KEY}" >> sonarqube-summary.md
            echo "- **Organization**: ${SONAR_ORGANIZATION}" >> sonarqube-summary.md
            echo "- **Branch**: ${CIRCLE_BRANCH}" >> sonarqube-summary.md
            echo "- **Commit**: ${CIRCLE_SHA1}" >> sonarqube-summary.md
            echo "" >> sonarqube-summary.md
            echo "### ðŸ”— View Results" >> sonarqube-summary.md
            echo "ðŸ“ˆ [View detailed analysis on SonarCloud](https://sonarcloud.io/project/overview?id=${SONAR_PROJECT_KEY})" >> sonarqube-summary.md
            echo "" >> sonarqube-summary.md
            echo "### Analysis Coverage" >> sonarqube-summary.md
            echo "- âœ… Code Quality Gates" >> sonarqube-summary.md
            echo "- âœ… Security Hotspots" >> sonarqube-summary.md
            echo "- âœ… Code Coverage Analysis" >> sonarqube-summary.md
            echo "- âœ… Code Duplication Detection" >> sonarqube-summary.md
            echo "- âœ… Maintainability Assessment" >> sonarqube-summary.md
      
      - store_artifacts:
          path: sonarqube-summary.md
          destination: quality-reports/sonarqube-summary.md

  # Docker Build and Scan
  build-and-scan-docker-image:
    executor: ubuntu-docker
    steps:
      - checkout
      
      - attach_workspace:
          at: .
      
      - setup_remote_docker:
          docker_layer_caching: true
      
      - run:
          name: Generate Docker Image Tags
          command: |
            # Create meaningful image tags based on context
            SHORT_SHA=${CIRCLE_SHA1:0:8}
            
            if [[ "${CIRCLE_BRANCH}" == "main" || "${CIRCLE_BRANCH}" == "master" ]]; then
              # Main branch: use semantic-like versioning with date and commit
              DATE_TAG=$(date +%Y.%m.%d)
              VERSION_TAG="${DATE_TAG}-${SHORT_SHA}"
              VERSIONED_IMAGE="${REGISTRY_PATH}/${IMAGE_NAME}:${VERSION_TAG}"
              LATEST_IMAGE="${REGISTRY_PATH}/${IMAGE_NAME}:latest"
              echo "export VERSIONED_IMAGE='${VERSIONED_IMAGE}'" >> $BASH_ENV
              echo "export LATEST_IMAGE='${LATEST_IMAGE}'" >> $BASH_ENV
              echo "export BUILD_LATEST='true'" >> $BASH_ENV
            elif [[ "${CIRCLE_BRANCH}" =~ ^v[0-9]+\.[0-9]+\.[0-9]+ ]]; then
              # Release tags: use the tag name directly
              VERSION_TAG="${CIRCLE_BRANCH}"
              VERSIONED_IMAGE="${REGISTRY_PATH}/${IMAGE_NAME}:${VERSION_TAG}"
              echo "export VERSIONED_IMAGE='${VERSIONED_IMAGE}'" >> $BASH_ENV
              echo "export BUILD_LATEST='false'" >> $BASH_ENV
            else
              # Feature branches: branch-commit-build format
              SAFE_BRANCH_NAME=$(echo "${CIRCLE_BRANCH}" | sed 's/[^a-zA-Z0-9]/-/g' | tr '[:upper:]' '[:lower:]')
              VERSION_TAG="${SAFE_BRANCH_NAME}-${SHORT_SHA}-${CIRCLE_BUILD_NUM}"
              VERSIONED_IMAGE="${REGISTRY_PATH}/${IMAGE_NAME}:${VERSION_TAG}"
              echo "export VERSIONED_IMAGE='${VERSIONED_IMAGE}'" >> $BASH_ENV
              echo "export BUILD_LATEST='false'" >> $BASH_ENV
            fi
            
            echo "export VERSION_TAG='${VERSION_TAG}'" >> $BASH_ENV
            echo "export SHORT_SHA='${SHORT_SHA}'" >> $BASH_ENV
            
            # Output for verification
            echo "Branch: ${CIRCLE_BRANCH}"
            echo "Commit: ${SHORT_SHA}"
            echo "Version Tag: ${VERSION_TAG}"
            echo "Versioned Image: ${VERSIONED_IMAGE}"
      
      - run:
          name: Build Docker Image
          command: |
            echo "Building Docker image..."
            echo "Image: ${VERSIONED_IMAGE}"
            
            if ! docker build -f ./Dotnet.Webapi/Dockerfile -t ${VERSIONED_IMAGE} .; then
              echo "âŒ Docker build failed"
              exit 1
            fi
            
            # Build latest tag for main branch
            if [[ "${BUILD_LATEST}" == "true" ]]; then
              if ! docker build -f ./Dotnet.Webapi/Dockerfile -t ${LATEST_IMAGE} .; then
                echo "âŒ Docker build failed for latest tag"
                exit 1
              fi
              echo "âœ… Also tagged as: ${LATEST_IMAGE}"
            fi
            
            echo "âœ… Docker build completed successfully"
      
      - run:
          name: Create Docker Build Summary
          command: |
            echo "## ðŸ³ Docker Image Build Summary" > docker-build-summary.md
            echo "" >> docker-build-summary.md
            echo "### Build Details" >> docker-build-summary.md
            echo "- **Branch**: ${CIRCLE_BRANCH}" >> docker-build-summary.md
            echo "- **Commit**: ${SHORT_SHA}" >> docker-build-summary.md
            echo "- **Version Tag**: ${VERSION_TAG}" >> docker-build-summary.md
            echo "- **Registry**: ${REGISTRY_PATH}" >> docker-build-summary.md
            echo "" >> docker-build-summary.md
            echo "### Built Images" >> docker-build-summary.md
            echo "- ðŸ“¦ \`${VERSIONED_IMAGE}\`" >> docker-build-summary.md
            if [[ "${BUILD_LATEST}" == "true" ]]; then
              echo "- ðŸ“¦ \`${LATEST_IMAGE}\`" >> docker-build-summary.md
            fi
            echo "" >> docker-build-summary.md
            echo "### Next Steps" >> docker-build-summary.md
            echo "- ðŸ” Security scanning with Snyk" >> docker-build-summary.md
            if [[ "${CIRCLE_BRANCH}" == "main" || "${CIRCLE_BRANCH}" == "master" ]]; then
              echo "- ðŸš€ Push to JFrog Artifactory (main branch)" >> docker-build-summary.md
            else
              echo "- â­ï¸ Scan only (feature branch - no push)" >> docker-build-summary.md
            fi
      
      - run:
          name: Install Snyk CLI for Container Scan
          command: |
            # Download and install Snyk CLI manually (no sudo required)
            curl -Lo /tmp/snyk https://github.com/snyk/cli/releases/latest/download/snyk-linux
            chmod +x /tmp/snyk
            echo 'export PATH="/tmp:$PATH"' >> $BASH_ENV
            
            # Verify installation
            /tmp/snyk --version
      
      - run:
          name: Authenticate Snyk
          command: /tmp/snyk auth $SNYK_TOKEN
      
      - run:
          name: Scan Docker Image with Snyk
          command: |
            echo "Scanning Docker image: ${VERSIONED_IMAGE}"
            
            # Scan the Docker image
            /tmp/snyk container test ${VERSIONED_IMAGE} \
              --severity-threshold=high \
              --sarif-file-output=snyk-docker.sarif \
              --json-file-output=snyk-docker-results.json \
              --file=./Dotnet.Webapi/Dockerfile || true
            
            echo "Docker image scan completed"
      
      - run:
          name: Create Docker Security Summary
          command: |
            echo "## ðŸ³ Docker Image Security Scan" > docker-security-summary.md
            echo "" >> docker-security-summary.md
            echo "### Scanned Image" >> docker-security-summary.md
            echo "- **Image**: \`${VERSIONED_IMAGE}\`" >> docker-security-summary.md
            echo "- **Base Image**: .NET 8 Runtime" >> docker-security-summary.md
            echo "- **Dockerfile**: \`./Dotnet.Webapi/Dockerfile\`" >> docker-security-summary.md
            echo "" >> docker-security-summary.md
            
            if [ -f snyk-docker-results.json ]; then
              # Parse container scan results
              CONTAINER_VULNS=$(cat snyk-docker-results.json | jq -r '.vulnerabilities | length' 2>/dev/null || echo "0")
              HIGH_CONTAINER_VULNS=$(cat snyk-docker-results.json | jq -r '[.vulnerabilities[] | select(.severity == "high")] | length' 2>/dev/null || echo "0")
              MEDIUM_CONTAINER_VULNS=$(cat snyk-docker-results.json | jq -r '[.vulnerabilities[] | select(.severity == "medium")] | length' 2>/dev/null || echo "0")
              LOW_CONTAINER_VULNS=$(cat snyk-docker-results.json | jq -r '[.vulnerabilities[] | select(.severity == "low")] | length' 2>/dev/null || echo "0")
              
              echo "### Container Vulnerability Summary" >> docker-security-summary.md
              echo "| Severity | Count |" >> docker-security-summary.md
              echo "|----------|-------|" >> docker-security-summary.md
              echo "| ðŸ”´ High | $HIGH_CONTAINER_VULNS |" >> docker-security-summary.md
              echo "| ðŸŸ¡ Medium | $MEDIUM_CONTAINER_VULNS |" >> docker-security-summary.md
              echo "| ðŸ”µ Low | $LOW_CONTAINER_VULNS |" >> docker-security-summary.md
              echo "| **Total** | **$CONTAINER_VULNS** |" >> docker-security-summary.md
              echo "" >> docker-security-summary.md
              
              if [ "$CONTAINER_VULNS" -gt "0" ]; then
                echo "âš ï¸ **Container Security Issues**: $CONTAINER_VULNS vulnerabilities found in base image or dependencies" >> docker-security-summary.md
              else
                echo "âœ… **Container Secure**: No vulnerabilities found in Docker image!" >> docker-security-summary.md
              fi
            else
              echo "âŒ **Container Scan Failed**: Unable to generate container vulnerability report" >> docker-security-summary.md
            fi
      
      - store_artifacts:
          path: docker-build-summary.md
          destination: docker-reports/docker-build-summary.md
      
      - store_artifacts:
          path: docker-security-summary.md
          destination: docker-reports/docker-security-summary.md
      
      - store_artifacts:
          path: snyk-docker.sarif
          destination: security-reports/snyk-docker.sarif
      
      - store_artifacts:
          path: snyk-docker-results.json
          destination: security-reports/snyk-docker-results.json
      
      - persist_to_workspace:
          root: .
          paths:
            - docker-build-summary.md
            - docker-security-summary.md

  # JFrog Registry Push
  push-docker-image-jfrog:
    executor: ubuntu-docker
    steps:
      - checkout
      
      - attach_workspace:
          at: .
      
      - setup_remote_docker:
          docker_layer_caching: true
      
      - artifactory/install
      
      - run:
          name: Configure JFrog CLI
          command: |
            # Configure JFrog CLI authentication
            echo "Configuring JFrog CLI..."
            
            # Check authentication options - prioritize Access Token
            if [ -n "${ARTIFACTORY_API_KEY}" ]; then
              echo "âœ… Using Access Token authentication"
              
              # Configure with Access Token
              if jfrog config add --url="${ARTIFACTORY_URL}" --access-token="${ARTIFACTORY_API_KEY}" --interactive=false; then
                echo "âœ… JFrog CLI configured successfully"
              else
                echo "âŒ Failed to configure JFrog CLI with Access Token"
                exit 1
              fi
              
            elif [ -n "${CIRCLE_OIDC_TOKEN}" ]; then
              echo "âš ï¸  Access Token not available, attempting OIDC authentication..."
              
              # Configure with OIDC token
              if jfrog config add --url="${ARTIFACTORY_URL}" --access-token="${CIRCLE_OIDC_TOKEN}" --interactive=false; then
                echo "âœ… JFrog CLI configured successfully with OIDC"
              else
                echo "âŒ Failed to configure JFrog CLI with OIDC token"
                echo ""
                echo "ðŸ› ï¸  TO FIX AUTHENTICATION:"
                echo "   1. Generate an Access Token in JFrog Artifactory"
                echo "   2. Add ARTIFACTORY_API_KEY to CircleCI context 'dotnet-webapi-security'"
                exit 1
              fi
            else
              echo "âŒ No authentication credentials available"
              echo ""
              echo "ðŸ› ï¸  TO FIX AUTHENTICATION:"
              echo "1. ðŸ”‘ RECOMMENDED: Generate an Access Token in JFrog Artifactory"
              echo "   - Go to JFrog > User Management > Access Tokens"
              echo "   - Add ARTIFACTORY_API_KEY to CircleCI context 'dotnet-webapi-security'"
              exit 1
            fi
            
            # Test the configuration
            echo "Testing JFrog connection..."
            if jfrog rt ping; then
              echo "âœ… JFrog connection successful!"
            else
              echo "âŒ JFrog connection failed"
              exit 1
            fi
          command: |
            # Configure JFrog CLI for OIDC authentication
            echo "Configuring JFrog CLI with OIDC..."
            echo "ARTIFACTORY_URL: ${ARTIFACTORY_URL}"
            echo "CircleCI Organization: ${CIRCLE_PROJECT_USERNAME}"
            echo "CircleCI Project: ${CIRCLE_PROJECT_REPONAME}"
            echo "CircleCI Branch: ${CIRCLE_BRANCH}"
            
            # Debug available environment variables
            echo "=== Available CIRCLE and OIDC variables ==="
            env | grep -E "^CIRCLE_" | sort
            echo "============================================"
            
            # Check authentication options - prioritize API key for now due to OIDC discovery issues
            if [ -n "${ARTIFACTORY_API_KEY}" ]; then
              echo "âœ… Using API key authentication (recommended for now)"
              echo "API key length: ${#ARTIFACTORY_API_KEY}"
              
              # Configure with API key
              if jfrog config add --url="${ARTIFACTORY_URL}" --access-token="${ARTIFACTORY_API_KEY}" --interactive=false; then
                echo "âœ… JFrog CLI configured successfully with API key"
              else
                echo "âŒ Failed to configure JFrog CLI with API key"
                exit 1
              fi
              
            elif [ -n "${CIRCLE_OIDC_TOKEN}" ]; then
              echo "âš ï¸  API key not available, attempting OIDC authentication..."
              echo "âš ï¸  Note: CircleCI OIDC discovery endpoints are currently not accessible"
              echo "Token length: ${#CIRCLE_OIDC_TOKEN}"
              echo "Token preview: ${CIRCLE_OIDC_TOKEN:0:20}..."
              
              # Try to decode JWT header to see issuer info (for debugging)
              echo "=== JWT Token Analysis ==="
              
              # Decode header
              HEADER=$(echo "${CIRCLE_OIDC_TOKEN}" | cut -d. -f1 | base64 -d 2>/dev/null || echo "{}")
              echo "JWT Header:"
              echo "${HEADER}" | jq . 2>/dev/null || echo "${HEADER}"
              
              # Decode payload
              PAYLOAD=$(echo "${CIRCLE_OIDC_TOKEN}" | cut -d. -f2 | base64 -d 2>/dev/null || echo "{}")
              echo "JWT Payload:"
              echo "${PAYLOAD}" | jq . 2>/dev/null || echo "${PAYLOAD}"
              
              # Extract key fields for JFrog OIDC configuration
              ISS=$(echo "${PAYLOAD}" | jq -r '.iss // "unknown"' 2>/dev/null)
              AUD=$(echo "${PAYLOAD}" | jq -r '.aud // "unknown"' 2>/dev/null)
              SUB=$(echo "${PAYLOAD}" | jq -r '.sub // "unknown"' 2>/dev/null)
              JTI=$(echo "${PAYLOAD}" | jq -r '.jti // "unknown"' 2>/dev/null)
              
              echo ""
              echo "ðŸ”‘ KEY OIDC CONFIGURATION VALUES:"
              echo "   Issuer (iss): ${ISS}"
              echo "   Audience (aud): ${AUD}"
              echo "   Subject (sub): ${SUB}"
              echo "   JWT ID (jti): ${JTI}"
              echo ""
              
              # Test CircleCI OIDC discovery endpoint
              echo "ðŸ” Testing CircleCI OIDC Discovery Endpoint:"
              DISCOVERY_URL="${ISS}/.well-known/openid_configuration"
              echo "   Primary endpoint: ${DISCOVERY_URL}"
              
              # Test the standard OIDC discovery endpoint
              if curl -s "${DISCOVERY_URL}" 2>/dev/null | jq . 2>/dev/null && ! curl -s "${DISCOVERY_URL}" 2>/dev/null | grep -q "Route Not Found"; then
                echo "âœ… CircleCI OIDC discovery endpoint is accessible"
                
                # Get the JWKS URI
                JWKS_URI=$(curl -s "${DISCOVERY_URL}" | jq -r '.jwks_uri // "unknown"' 2>/dev/null)
                echo "   JWKS URI: ${JWKS_URI}"
                
                if [ "${JWKS_URI}" != "unknown" ] && [ -n "${JWKS_URI}" ]; then
                  echo "   Testing JWKS endpoint:"
                  if curl -s "${JWKS_URI}" | jq . 2>/dev/null; then
                    echo "âœ… CircleCI JWKS endpoint is accessible"
                    echo "   âš ï¸  JFrog must be able to access both URLs above for signature verification"
                  else
                    echo "âŒ CircleCI JWKS endpoint is not accessible"
                  fi
                fi
              else
                echo "âŒ CircleCI OIDC discovery endpoints are not accessible"
                echo "   This is a known issue - CircleCI's OIDC service structure differs from standard"
                echo "   Recommendation: Use API key authentication instead"
              fi
              echo ""
              
              echo "Attempting OIDC authentication (will likely fail due to discovery endpoint issues)..."
              # Configure with OIDC token
              if jfrog config add --url="${ARTIFACTORY_URL}" --access-token="${CIRCLE_OIDC_TOKEN}" --interactive=false; then
                echo "âœ… JFrog CLI configured successfully with OIDC"
              else
                echo "âŒ Failed to configure JFrog CLI with OIDC token"
                echo ""
                echo "ï¿½ OIDC AUTHENTICATION ISSUE:"
                echo "   CircleCI's OIDC discovery endpoints are not accessible:"
                echo "   - ${ISS}/.well-known/openid_configuration returns 'Route Not Found'"
                echo "   - https://oidc.circleci.com/.well-known/openid_configuration returns 'Route Not Found'"
                echo ""
                echo "ï¿½ï¸  SOLUTION:"
                echo "   1. Generate an API key in JFrog Artifactory"
                echo "   2. Add ARTIFACTORY_API_KEY to CircleCI context 'dotnet-webapi-security'"
                echo "   3. This will use reliable API key authentication instead of OIDC"
                exit 1
              fi
            else
              echo "âŒ Neither API key nor OIDC token available"
              echo "Available environment variables:"
              env | grep -E "(CIRCLE_|ARTIFACTORY_|JF_)" | sort
              echo ""
              echo "ðŸ› ï¸  TO FIX AUTHENTICATION:"
              echo "1. ðŸ”‘ RECOMMENDED: Generate an API key in JFrog Artifactory"
              echo "   - Go to JFrog > User Profile > Generate API Key"
              echo "   - Add ARTIFACTORY_API_KEY to CircleCI context 'dotnet-webapi-security'"
              echo ""
              echo "2. ðŸ”„ ALTERNATIVE: Fix OIDC integration (more complex)"
              echo "   - CircleCI's OIDC discovery endpoints are currently not standard"
              echo "   - Contact CircleCI support for correct OIDC discovery URL format"
      
      - run:
          name: Generate Docker Image Tags for Push
          command: |
            # Recreate the same image naming logic as build step
            SHORT_SHA=${CIRCLE_SHA1:0:8}
            
            if [[ "${CIRCLE_BRANCH}" == "main" || "${CIRCLE_BRANCH}" == "master" ]]; then
              DATE_TAG=$(date +%Y.%m.%d)
              VERSION_TAG="${DATE_TAG}-${SHORT_SHA}"
              VERSIONED_IMAGE="${REGISTRY_PATH}/${IMAGE_NAME}:${VERSION_TAG}"
              LATEST_IMAGE="${REGISTRY_PATH}/${IMAGE_NAME}:latest"
              echo "export VERSIONED_IMAGE='${VERSIONED_IMAGE}'" >> $BASH_ENV
              echo "export LATEST_IMAGE='${LATEST_IMAGE}'" >> $BASH_ENV
              echo "export PUSH_LATEST='true'" >> $BASH_ENV
            elif [[ "${CIRCLE_BRANCH}" =~ ^v[0-9]+\.[0-9]+\.[0-9]+ ]]; then
              VERSION_TAG="${CIRCLE_BRANCH}"
              VERSIONED_IMAGE="${REGISTRY_PATH}/${IMAGE_NAME}:${VERSION_TAG}"
              echo "export VERSIONED_IMAGE='${VERSIONED_IMAGE}'" >> $BASH_ENV
              echo "export PUSH_LATEST='false'" >> $BASH_ENV
            else
              SAFE_BRANCH_NAME=$(echo "${CIRCLE_BRANCH}" | sed 's/[^a-zA-Z0-9]/-/g' | tr '[:upper:]' '[:lower:]')
              VERSION_TAG="${SAFE_BRANCH_NAME}-${SHORT_SHA}-${CIRCLE_BUILD_NUM}"
              VERSIONED_IMAGE="${REGISTRY_PATH}/${IMAGE_NAME}:${VERSION_TAG}"
              echo "export VERSIONED_IMAGE='${VERSIONED_IMAGE}'" >> $BASH_ENV
              echo "export PUSH_LATEST='false'" >> $BASH_ENV
            fi
            
            echo "export VERSION_TAG='${VERSION_TAG}'" >> $BASH_ENV
            echo "export SHORT_SHA='${SHORT_SHA}'" >> $BASH_ENV
      
      - run:
          name: Rebuild Docker Image for Push
          command: |
            echo "Rebuilding Docker image for push..."
            echo "Branch: ${CIRCLE_BRANCH}"
            echo "Commit: ${SHORT_SHA}"
            echo "Version Tag: ${VERSION_TAG}"
            echo "Image: ${VERSIONED_IMAGE}"
            
            if ! docker build -f ./Dotnet.Webapi/Dockerfile -t ${VERSIONED_IMAGE} .; then
              echo "âŒ Docker build failed"
              exit 1
            fi
            
            # Build latest tag for main branch
            if [[ "${PUSH_LATEST}" == "true" ]]; then
              if ! docker build -f ./Dotnet.Webapi/Dockerfile -t ${LATEST_IMAGE} .; then
                echo "âŒ Docker build failed for latest tag"
                exit 1
              fi
              echo "âœ… Also built: ${LATEST_IMAGE}"
            fi
            
            echo "âœ… Docker image rebuilt successfully"
      
      - run:
          name: Push Docker Image to JFrog
          command: |
            echo "Pushing image to JFrog Artifactory..."
            echo "Branch: ${CIRCLE_BRANCH}"
            echo "Commit: ${SHORT_SHA}"
            echo "Version Tag: ${VERSION_TAG}"
            echo "Image: ${VERSIONED_IMAGE}"
            
            if ! jfrog rt docker-push ${VERSIONED_IMAGE} alley-oop-container/circleci; then
              echo "âŒ Failed to push versioned image"
              exit 1
            fi
            
            # Push latest tag for main branch
            if [[ "${PUSH_LATEST}" == "true" ]]; then
              echo "Pushing latest tag..."
              if ! jfrog rt docker-push ${LATEST_IMAGE} alley-oop-container/circleci; then
                echo "âŒ Failed to push latest image"
                exit 1
              fi
            fi
      
      - artifactory/build-integration
      
      - run:
          name: Create Deployment Summary
          command: |
            echo "## ðŸš€ Docker Image Deployment Summary" > deployment-summary.md
            echo "" >> deployment-summary.md
            echo "### Deployment Details" >> deployment-summary.md
            echo "- **Registry**: JFrog Artifactory" >> deployment-summary.md
            echo "- **Repository**: ${REGISTRY_PATH}" >> deployment-summary.md
            echo "- **Branch**: ${CIRCLE_BRANCH}" >> deployment-summary.md
            echo "- **Commit**: ${SHORT_SHA}" >> deployment-summary.md
            echo "- **Build Number**: ${CIRCLE_BUILD_NUM}" >> deployment-summary.md
            echo "" >> deployment-summary.md
            echo "### ðŸ“¦ Pushed Images" >> deployment-summary.md
            echo "- âœ… \`${VERSIONED_IMAGE}\`" >> deployment-summary.md
            if [[ "${PUSH_LATEST}" == "true" ]]; then
              echo "- âœ… \`${LATEST_IMAGE}\`" >> deployment-summary.md
              echo "" >> deployment-summary.md
              echo "### ðŸŽ¯ Deployment Ready" >> deployment-summary.md
              echo "This image is now available for production deployment!" >> deployment-summary.md
            else
              echo "" >> deployment-summary.md
              echo "### ðŸ§ª Development Image" >> deployment-summary.md
              echo "This feature branch image is available for testing." >> deployment-summary.md
            fi
            echo "" >> deployment-summary.md
            echo "### ðŸ“Š Build Artifacts" >> deployment-summary.md
            echo "- âœ… Security scanned (Snyk)" >> deployment-summary.md
            echo "- âœ… Code quality checked (SonarQube)" >> deployment-summary.md
            echo "- âœ… Tests passed" >> deployment-summary.md
            echo "- âœ… Container security verified" >> deployment-summary.md
      
      - store_artifacts:
          path: deployment-summary.md
          destination: deployment-reports/deployment-summary.md

# Workflows
workflows:
  version: 2
  
  # Main CI/CD Pipeline
  ci-cd-pipeline:
    jobs:
      # Build and test
      - build-and-test:
          filters:
            branches:
              only: /.*/
      
      # Security and quality analysis
      - snyk-security-scan:
          context: dotnet-webapi-security
          requires:
            - build-and-test
          filters:
            branches:
              only: /.*/
      
      - sonarqube-scan:
          context: dotnet-webapi-security
          requires:
            - build-and-test
          filters:
            branches:
              only: /.*/
      
      # Docker build and scan
      - build-and-scan-docker-image:
          context: dotnet-webapi-security
          requires:
            - build-and-test
            - snyk-security-scan
            - sonarqube-scan
          filters:
            branches:
              only: /.*/
      
      # Deploy to JFrog registry  
      - push-docker-image-jfrog:
          context: dotnet-webapi-security
          requires:
            - build-and-scan-docker-image
          filters:
            branches:
              only: /.*/ 
