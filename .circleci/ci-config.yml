version: 2.1

# ============================================================================
# CircleCI Pipeline for .NET Web API
# Comprehensive CI/CD pipeline with security scanning, code quality, and deployment
# ============================================================================

# Environment variables
environment: &default_environment
  DOTNET_VERSION: "8.0.x"
  IMAGE_NAME: "dotnet-webapi"
  REGISTRY_PATH: "hkjctest.jfrog.io/alley-oop-container/circleci"
  SONAR_PROJECT_KEY: "thiago-tota_gha-dotnet-webapi"
  SONAR_ORGANIZATION: "thiago-tota"

# Orbs for extended functionality
orbs:
  docker: circleci/docker@2.8.2
  snyk: snyk/snyk@2.3.0
  artifactory: circleci/artifactory@1.0.0
  sonarcloud: sonarsource/sonarcloud@3.0.0

# Executors
executors:
  dotnet-executor:
    docker:
      - image: mcr.microsoft.com/dotnet/sdk:8.0
    environment:
      <<: *default_environment
  
  ubuntu-docker:
    docker:
      - image: cimg/base:stable
    environment:
      <<: *default_environment

# Jobs
jobs:
  # ============================================================================
  # BUILD AND TEST JOB
  # ============================================================================
  build-and-test:
    executor: dotnet-executor
    steps:
      - checkout
      
      - run:
          name: Display .NET Version
          command: dotnet --version
      
      - run:
          name: Restore Dependencies
          command: dotnet restore
      
      - run:
          name: Build Solution
          command: dotnet build --configuration Release --no-restore
      
      - run:
          name: Run Unit Tests
          command: |
            dotnet test Dotnet.Webapi.Tests/Dotnet.Webapi.Tests.csproj \
              --configuration Release \
              --no-build \
              --verbosity normal \
              --logger trx \
              --results-directory TestResults
      
      - store_test_results:
          path: TestResults
      
      - store_artifacts:
          path: TestResults
          destination: test-results
      
      - persist_to_workspace:
          root: .
          paths:
            - Dotnet.Webapi/bin/Release/net8.0
            - Dotnet.Webapi/Dockerfile
            - TestResults

  # ============================================================================
  # SNYK SECURITY SCAN JOB
  # ============================================================================
  snyk-security-scan:
    executor: dotnet-executor
    steps:
      - checkout
      
      - attach_workspace:
          at: .
      
      - run:
          name: Restore Dependencies
          command: dotnet restore
      
      - run:
          name: Build for Snyk Analysis
          command: dotnet build --configuration Release --no-restore
      
      - run:
          name: Install Snyk CLI
          command: |
            # Download and install Snyk CLI manually (no sudo required)
            curl -Lo /tmp/snyk https://github.com/snyk/cli/releases/latest/download/snyk-linux
            chmod +x /tmp/snyk
            echo 'export PATH="/tmp:$PATH"' >> $BASH_ENV
            
            # Verify installation
            /tmp/snyk --version
      
      - run:
          name: Authenticate Snyk
          command: /tmp/snyk auth $SNYK_TOKEN
      
      - run:
          name: Run Snyk Security Scan
          command: |
            echo "Running Snyk security scan..."
            
            # Scan for vulnerabilities
            /tmp/snyk test \
              --severity-threshold=high \
              --sarif-file-output=snyk.sarif \
              --json-file-output=snyk-results.json || true
            
            echo "Snyk security scan completed"
      
      - run:
          name: Create Snyk Security Summary
          command: |
            echo "## 🛡️ Snyk Security Scan Results" > snyk-summary.md
            echo "" >> snyk-summary.md
            
            if [ -f snyk-results.json ]; then
              # Parse JSON results and create summary
              VULNERABILITIES=$(cat snyk-results.json | jq -r '.vulnerabilities | length' 2>/dev/null || echo "0")
              HIGH_VULNS=$(cat snyk-results.json | jq -r '[.vulnerabilities[] | select(.severity == "high")] | length' 2>/dev/null || echo "0")
              MEDIUM_VULNS=$(cat snyk-results.json | jq -r '[.vulnerabilities[] | select(.severity == "medium")] | length' 2>/dev/null || echo "0")
              LOW_VULNS=$(cat snyk-results.json | jq -r '[.vulnerabilities[] | select(.severity == "low")] | length' 2>/dev/null || echo "0")
              
              echo "### Code Vulnerability Summary" >> snyk-summary.md
              echo "| Severity | Count |" >> snyk-summary.md
              echo "|----------|-------|" >> snyk-summary.md
              echo "| 🔴 High | $HIGH_VULNS |" >> snyk-summary.md
              echo "| 🟡 Medium | $MEDIUM_VULNS |" >> snyk-summary.md
              echo "| 🔵 Low | $LOW_VULNS |" >> snyk-summary.md
              echo "| **Total** | **$VULNERABILITIES** |" >> snyk-summary.md
              echo "" >> snyk-summary.md
              
              if [ "$VULNERABILITIES" -gt "0" ]; then
                echo "⚠️ **Action Required**: $VULNERABILITIES vulnerabilities found in dependencies" >> snyk-summary.md
              else
                echo "✅ **No vulnerabilities found** - All dependencies are secure!" >> snyk-summary.md
              fi
            else
              echo "❌ **Scan Failed**: Unable to generate vulnerability report" >> snyk-summary.md
            fi
      
      - store_artifacts:
          path: snyk.sarif
          destination: security-reports/snyk.sarif
      
      - store_artifacts:
          path: snyk-results.json
          destination: security-reports/snyk-results.json
      
      - store_artifacts:
          path: snyk-summary.md
          destination: security-reports/snyk-summary.md

  # ============================================================================
  # SONARQUBE CODE QUALITY SCAN JOB
  # ============================================================================
  sonarqube-scan:
    executor: dotnet-executor
    steps:
      - checkout
      
      - attach_workspace:
          at: .
      
      - run:
          name: Install Required Tools
          command: |
            # Update package list and install unzip (required by SonarCloud orb)
            apt-get update
            apt-get install -y unzip
      
      - run:
          name: Restore Dependencies
          command: dotnet restore
      
      - run:
          name: Build and Test with Coverage
          command: |
            dotnet build --configuration Release --no-restore
            dotnet test Dotnet.Webapi.Tests/Dotnet.Webapi.Tests.csproj \
              --configuration Release \
              --no-build \
              --logger trx \
              --results-directory TestResults \
              --collect:"XPlat Code Coverage" \
              --settings coverlet.runsettings
      
      - run:
          name: Create SonarCloud Configuration
          command: |
            echo "sonar.projectKey=${SONAR_PROJECT_KEY}" > sonar-project.properties
            echo "sonar.organization=${SONAR_ORGANIZATION}" >> sonar-project.properties
            echo "sonar.host.url=https://sonarcloud.io" >> sonar-project.properties
            echo "sonar.sources=Dotnet.Webapi" >> sonar-project.properties
            echo "sonar.tests=Dotnet.Webapi.Tests" >> sonar-project.properties
            echo "sonar.cs.dotcover.reportsPaths=**/TestResults/**/coverage.cobertura.xml" >> sonar-project.properties
            echo "sonar.cs.vstest.reportsPaths=**/TestResults/*.trx" >> sonar-project.properties
            cat sonar-project.properties
      
      - sonarcloud/scan:
          sonar_token_variable_name: SONAR_TOKEN
          cache_version: 1
      
      - run:
          name: Create SonarQube Summary
          command: |
            echo "## 📊 SonarQube Code Quality Analysis" > sonarqube-summary.md
            echo "" >> sonarqube-summary.md
            echo "### Analysis Details" >> sonarqube-summary.md
            echo "- **Project**: ${SONAR_PROJECT_KEY}" >> sonarqube-summary.md
            echo "- **Organization**: ${SONAR_ORGANIZATION}" >> sonarqube-summary.md
            echo "- **Branch**: ${CIRCLE_BRANCH}" >> sonarqube-summary.md
            echo "- **Commit**: ${CIRCLE_SHA1}" >> sonarqube-summary.md
            echo "" >> sonarqube-summary.md
            echo "### 🔗 View Results" >> sonarqube-summary.md
            echo "📈 [View detailed analysis on SonarCloud](https://sonarcloud.io/project/overview?id=${SONAR_PROJECT_KEY})" >> sonarqube-summary.md
            echo "" >> sonarqube-summary.md
            echo "### Analysis Coverage" >> sonarqube-summary.md
            echo "- ✅ Code Quality Gates" >> sonarqube-summary.md
            echo "- ✅ Security Hotspots" >> sonarqube-summary.md
            echo "- ✅ Code Coverage Analysis" >> sonarqube-summary.md
            echo "- ✅ Code Duplication Detection" >> sonarqube-summary.md
            echo "- ✅ Maintainability Assessment" >> sonarqube-summary.md
      
      - store_artifacts:
          path: sonarqube-summary.md
          destination: quality-reports/sonarqube-summary.md

  # ============================================================================
  # DOCKER BUILD AND SCAN JOB
  # ============================================================================
  build-and-scan-docker-image:
    executor: ubuntu-docker
    steps:
      - checkout
      
      - attach_workspace:
          at: .
      
      - setup_remote_docker:
          docker_layer_caching: true
      
      - run:
          name: Generate Docker Image Tags
          command: |
            # Create meaningful image tags based on context
            SHORT_SHA=${CIRCLE_SHA1:0:8}
            
            if [[ "${CIRCLE_BRANCH}" == "main" || "${CIRCLE_BRANCH}" == "master" ]]; then
              # Main branch: use semantic-like versioning with date and commit
              DATE_TAG=$(date +%Y.%m.%d)
              VERSION_TAG="${DATE_TAG}-${SHORT_SHA}"
              VERSIONED_IMAGE="${REGISTRY_PATH}/${IMAGE_NAME}:${VERSION_TAG}"
              LATEST_IMAGE="${REGISTRY_PATH}/${IMAGE_NAME}:latest"
              echo "export VERSIONED_IMAGE='${VERSIONED_IMAGE}'" >> $BASH_ENV
              echo "export LATEST_IMAGE='${LATEST_IMAGE}'" >> $BASH_ENV
              echo "export BUILD_LATEST='true'" >> $BASH_ENV
            elif [[ "${CIRCLE_BRANCH}" =~ ^v[0-9]+\.[0-9]+\.[0-9]+ ]]; then
              # Release tags: use the tag name directly
              VERSION_TAG="${CIRCLE_BRANCH}"
              VERSIONED_IMAGE="${REGISTRY_PATH}/${IMAGE_NAME}:${VERSION_TAG}"
              echo "export VERSIONED_IMAGE='${VERSIONED_IMAGE}'" >> $BASH_ENV
              echo "export BUILD_LATEST='false'" >> $BASH_ENV
            else
              # Feature branches: branch-commit-build format
              SAFE_BRANCH_NAME=$(echo "${CIRCLE_BRANCH}" | sed 's/[^a-zA-Z0-9]/-/g' | tr '[:upper:]' '[:lower:]')
              VERSION_TAG="${SAFE_BRANCH_NAME}-${SHORT_SHA}-${CIRCLE_BUILD_NUM}"
              VERSIONED_IMAGE="${REGISTRY_PATH}/${IMAGE_NAME}:${VERSION_TAG}"
              echo "export VERSIONED_IMAGE='${VERSIONED_IMAGE}'" >> $BASH_ENV
              echo "export BUILD_LATEST='false'" >> $BASH_ENV
            fi
            
            echo "export VERSION_TAG='${VERSION_TAG}'" >> $BASH_ENV
            echo "export SHORT_SHA='${SHORT_SHA}'" >> $BASH_ENV
            
            # Output for verification
            echo "Branch: ${CIRCLE_BRANCH}"
            echo "Commit: ${SHORT_SHA}"
            echo "Version Tag: ${VERSION_TAG}"
            echo "Versioned Image: ${VERSIONED_IMAGE}"
      
      - run:
          name: Build Docker Image
          command: |
            echo "Building Docker image..."
            echo "Image: ${VERSIONED_IMAGE}"
            
            if ! docker build -f ./Dotnet.Webapi/Dockerfile -t ${VERSIONED_IMAGE} .; then
              echo "❌ Docker build failed"
              exit 1
            fi
            
            # Build latest tag for main branch
            if [[ "${BUILD_LATEST}" == "true" ]]; then
              if ! docker build -f ./Dotnet.Webapi/Dockerfile -t ${LATEST_IMAGE} .; then
                echo "❌ Docker build failed for latest tag"
                exit 1
              fi
              echo "✅ Also tagged as: ${LATEST_IMAGE}"
            fi
            
            echo "✅ Docker build completed successfully"
      
      - run:
          name: Create Docker Build Summary
          command: |
            echo "## 🐳 Docker Image Build Summary" > docker-build-summary.md
            echo "" >> docker-build-summary.md
            echo "### Build Details" >> docker-build-summary.md
            echo "- **Branch**: ${CIRCLE_BRANCH}" >> docker-build-summary.md
            echo "- **Commit**: ${SHORT_SHA}" >> docker-build-summary.md
            echo "- **Version Tag**: ${VERSION_TAG}" >> docker-build-summary.md
            echo "- **Registry**: ${REGISTRY_PATH}" >> docker-build-summary.md
            echo "" >> docker-build-summary.md
            echo "### Built Images" >> docker-build-summary.md
            echo "- 📦 \`${VERSIONED_IMAGE}\`" >> docker-build-summary.md
            if [[ "${BUILD_LATEST}" == "true" ]]; then
              echo "- 📦 \`${LATEST_IMAGE}\`" >> docker-build-summary.md
            fi
            echo "" >> docker-build-summary.md
            echo "### Next Steps" >> docker-build-summary.md
            echo "- 🔍 Security scanning with Snyk" >> docker-build-summary.md
            if [[ "${CIRCLE_BRANCH}" == "main" || "${CIRCLE_BRANCH}" == "master" ]]; then
              echo "- 🚀 Push to JFrog Artifactory (main branch)" >> docker-build-summary.md
            else
              echo "- ⏭️ Scan only (feature branch - no push)" >> docker-build-summary.md
            fi
      
      - run:
          name: Install Snyk CLI for Container Scan
          command: |
            # Download and install Snyk CLI manually (no sudo required)
            curl -Lo /tmp/snyk https://github.com/snyk/cli/releases/latest/download/snyk-linux
            chmod +x /tmp/snyk
            echo 'export PATH="/tmp:$PATH"' >> $BASH_ENV
            
            # Verify installation
            /tmp/snyk --version
      
      - run:
          name: Authenticate Snyk
          command: /tmp/snyk auth $SNYK_TOKEN
      
      - run:
          name: Scan Docker Image with Snyk
          command: |
            echo "Scanning Docker image: ${VERSIONED_IMAGE}"
            
            # Scan the Docker image
            /tmp/snyk container test ${VERSIONED_IMAGE} \
              --severity-threshold=high \
              --sarif-file-output=snyk-docker.sarif \
              --json-file-output=snyk-docker-results.json \
              --file=./Dotnet.Webapi/Dockerfile || true
            
            echo "Docker image scan completed"
      
      - run:
          name: Create Docker Security Summary
          command: |
            echo "## 🐳 Docker Image Security Scan" > docker-security-summary.md
            echo "" >> docker-security-summary.md
            echo "### Scanned Image" >> docker-security-summary.md
            echo "- **Image**: \`${VERSIONED_IMAGE}\`" >> docker-security-summary.md
            echo "- **Base Image**: .NET 8 Runtime" >> docker-security-summary.md
            echo "- **Dockerfile**: \`./Dotnet.Webapi/Dockerfile\`" >> docker-security-summary.md
            echo "" >> docker-security-summary.md
            
            if [ -f snyk-docker-results.json ]; then
              # Parse container scan results
              CONTAINER_VULNS=$(cat snyk-docker-results.json | jq -r '.vulnerabilities | length' 2>/dev/null || echo "0")
              HIGH_CONTAINER_VULNS=$(cat snyk-docker-results.json | jq -r '[.vulnerabilities[] | select(.severity == "high")] | length' 2>/dev/null || echo "0")
              MEDIUM_CONTAINER_VULNS=$(cat snyk-docker-results.json | jq -r '[.vulnerabilities[] | select(.severity == "medium")] | length' 2>/dev/null || echo "0")
              LOW_CONTAINER_VULNS=$(cat snyk-docker-results.json | jq -r '[.vulnerabilities[] | select(.severity == "low")] | length' 2>/dev/null || echo "0")
              
              echo "### Container Vulnerability Summary" >> docker-security-summary.md
              echo "| Severity | Count |" >> docker-security-summary.md
              echo "|----------|-------|" >> docker-security-summary.md
              echo "| 🔴 High | $HIGH_CONTAINER_VULNS |" >> docker-security-summary.md
              echo "| 🟡 Medium | $MEDIUM_CONTAINER_VULNS |" >> docker-security-summary.md
              echo "| 🔵 Low | $LOW_CONTAINER_VULNS |" >> docker-security-summary.md
              echo "| **Total** | **$CONTAINER_VULNS** |" >> docker-security-summary.md
              echo "" >> docker-security-summary.md
              
              if [ "$CONTAINER_VULNS" -gt "0" ]; then
                echo "⚠️ **Container Security Issues**: $CONTAINER_VULNS vulnerabilities found in base image or dependencies" >> docker-security-summary.md
              else
                echo "✅ **Container Secure**: No vulnerabilities found in Docker image!" >> docker-security-summary.md
              fi
            else
              echo "❌ **Container Scan Failed**: Unable to generate container vulnerability report" >> docker-security-summary.md
            fi
      
      - store_artifacts:
          path: docker-build-summary.md
          destination: docker-reports/docker-build-summary.md
      
      - store_artifacts:
          path: docker-security-summary.md
          destination: docker-reports/docker-security-summary.md
      
      - store_artifacts:
          path: snyk-docker.sarif
          destination: security-reports/snyk-docker.sarif
      
      - store_artifacts:
          path: snyk-docker-results.json
          destination: security-reports/snyk-docker-results.json
      
      - persist_to_workspace:
          root: .
          paths:
            - docker-build-summary.md
            - docker-security-summary.md

  # ============================================================================
  # JFROG REGISTRY PUSH JOB (Using orb commands)
  # ============================================================================
  push-docker-image-jfrog:
    executor: ubuntu-docker
    steps:
      - checkout
      
      - attach_workspace:
          at: .
      
      - setup_remote_docker:
          docker_layer_caching: true
      
      - artifactory/install
      
      - run:
          name: Configure JFrog CLI for OIDC
          command: |
            # Configure JFrog CLI for OIDC authentication
            echo "Configuring JFrog CLI with OIDC..."
            echo "ARTIFACTORY_URL: ${ARTIFACTORY_URL}"
            echo "CircleCI Organization: ${CIRCLE_PROJECT_USERNAME}"
            echo "CircleCI Project: ${CIRCLE_PROJECT_REPONAME}"
            echo "CircleCI Branch: ${CIRCLE_BRANCH}"
            
            # Debug available environment variables
            echo "=== Available CIRCLE and OIDC variables ==="
            env | grep -E "^CIRCLE_" | sort
            echo "============================================"
            
            # Check if OIDC environment variables are available
            if [ -n "${CIRCLE_OIDC_TOKEN}" ]; then
              echo "✅ OIDC token is available"
              echo "Token length: ${#CIRCLE_OIDC_TOKEN}"
              echo "Token preview: ${CIRCLE_OIDC_TOKEN:0:20}..."
              
              # Try to decode JWT header to see issuer info (for debugging)
              echo "=== JWT Token Info ==="
              echo "${CIRCLE_OIDC_TOKEN}" | cut -d. -f1 | base64 -d 2>/dev/null | jq . || echo "Could not decode JWT header"
              echo "${CIRCLE_OIDC_TOKEN}" | cut -d. -f2 | base64 -d 2>/dev/null | jq . || echo "Could not decode JWT payload"
              echo "====================="
              
              echo "Attempting OIDC authentication..."
              # Configure with OIDC token
              if jfrog config add --url="${ARTIFACTORY_URL}" --access-token="${CIRCLE_OIDC_TOKEN}" --interactive=false; then
                echo "✅ JFrog CLI configured successfully with OIDC"
              else
                echo "❌ Failed to configure JFrog CLI with OIDC token"
                echo "This might mean:"
                echo "1. OIDC integration is not set up in JFrog"
                echo "2. OIDC integration configuration is incorrect"
                echo "3. CircleCI project is not authorized"
                exit 1
              fi
              
            elif [ -n "${ARTIFACTORY_API_KEY}" ]; then
              echo "⚠️  OIDC not available, falling back to API key authentication"
              # Fallback to API key if OIDC is not available
              jfrog config add --url="${ARTIFACTORY_URL}" --access-token="${ARTIFACTORY_API_KEY}" --interactive=false
            else
              echo "❌ Neither OIDC token nor API key available"
              echo "Available environment variables:"
              env | grep -E "(CIRCLE_|ARTIFACTORY_|JF_)" | sort
              echo ""
              echo "To fix this:"
              echo "1. Set up OIDC integration in JFrog (recommended)"
              echo "2. OR set ARTIFACTORY_API_KEY environment variable"
              exit 1
            fi
            
            # Test the configuration
            echo "Testing JFrog connection..."
            if jfrog rt ping; then
              echo "✅ JFrog connection successful!"
            else
              echo "❌ JFrog connection failed"
              echo "Check your OIDC integration setup in JFrog"
              exit 1
            fi
      
      - run:
          name: Generate Docker Image Tags for Push
          command: |
            # Recreate the same image naming logic as build step
            SHORT_SHA=${CIRCLE_SHA1:0:8}
            
            if [[ "${CIRCLE_BRANCH}" == "main" || "${CIRCLE_BRANCH}" == "master" ]]; then
              DATE_TAG=$(date +%Y.%m.%d)
              VERSION_TAG="${DATE_TAG}-${SHORT_SHA}"
              VERSIONED_IMAGE="${REGISTRY_PATH}/${IMAGE_NAME}:${VERSION_TAG}"
              LATEST_IMAGE="${REGISTRY_PATH}/${IMAGE_NAME}:latest"
              echo "export VERSIONED_IMAGE='${VERSIONED_IMAGE}'" >> $BASH_ENV
              echo "export LATEST_IMAGE='${LATEST_IMAGE}'" >> $BASH_ENV
              echo "export PUSH_LATEST='true'" >> $BASH_ENV
            elif [[ "${CIRCLE_BRANCH}" =~ ^v[0-9]+\.[0-9]+\.[0-9]+ ]]; then
              VERSION_TAG="${CIRCLE_BRANCH}"
              VERSIONED_IMAGE="${REGISTRY_PATH}/${IMAGE_NAME}:${VERSION_TAG}"
              echo "export VERSIONED_IMAGE='${VERSIONED_IMAGE}'" >> $BASH_ENV
              echo "export PUSH_LATEST='false'" >> $BASH_ENV
            else
              SAFE_BRANCH_NAME=$(echo "${CIRCLE_BRANCH}" | sed 's/[^a-zA-Z0-9]/-/g' | tr '[:upper:]' '[:lower:]')
              VERSION_TAG="${SAFE_BRANCH_NAME}-${SHORT_SHA}-${CIRCLE_BUILD_NUM}"
              VERSIONED_IMAGE="${REGISTRY_PATH}/${IMAGE_NAME}:${VERSION_TAG}"
              echo "export VERSIONED_IMAGE='${VERSIONED_IMAGE}'" >> $BASH_ENV
              echo "export PUSH_LATEST='false'" >> $BASH_ENV
            fi
            
            echo "export VERSION_TAG='${VERSION_TAG}'" >> $BASH_ENV
            echo "export SHORT_SHA='${SHORT_SHA}'" >> $BASH_ENV
      
      - run:
          name: Rebuild Docker Image for Push
          command: |
            echo "Rebuilding Docker image for push..."
            echo "Branch: ${CIRCLE_BRANCH}"
            echo "Commit: ${SHORT_SHA}"
            echo "Version Tag: ${VERSION_TAG}"
            echo "Image: ${VERSIONED_IMAGE}"
            
            if ! docker build -f ./Dotnet.Webapi/Dockerfile -t ${VERSIONED_IMAGE} .; then
              echo "❌ Docker build failed"
              exit 1
            fi
            
            # Build latest tag for main branch
            if [[ "${PUSH_LATEST}" == "true" ]]; then
              if ! docker build -f ./Dotnet.Webapi/Dockerfile -t ${LATEST_IMAGE} .; then
                echo "❌ Docker build failed for latest tag"
                exit 1
              fi
              echo "✅ Also built: ${LATEST_IMAGE}"
            fi
            
            echo "✅ Docker image rebuilt successfully"
      
      - run:
          name: Push Docker Image to JFrog
          command: |
            echo "Pushing image to JFrog Artifactory..."
            echo "Branch: ${CIRCLE_BRANCH}"
            echo "Commit: ${SHORT_SHA}"
            echo "Version Tag: ${VERSION_TAG}"
            echo "Image: ${VERSIONED_IMAGE}"
            
            if ! jfrog rt docker-push ${VERSIONED_IMAGE} alley-oop-container/circleci; then
              echo "❌ Failed to push versioned image"
              exit 1
            fi
            
            # Push latest tag for main branch
            if [[ "${PUSH_LATEST}" == "true" ]]; then
              echo "Pushing latest tag..."
              if ! jfrog rt docker-push ${LATEST_IMAGE} alley-oop-container/circleci; then
                echo "❌ Failed to push latest image"
                exit 1
              fi
            fi
      
      - artifactory/build-integration
      
      - run:
          name: Create Deployment Summary
          command: |
            echo "## 🚀 Docker Image Deployment Summary" > deployment-summary.md
            echo "" >> deployment-summary.md
            echo "### Deployment Details" >> deployment-summary.md
            echo "- **Registry**: JFrog Artifactory" >> deployment-summary.md
            echo "- **Repository**: ${REGISTRY_PATH}" >> deployment-summary.md
            echo "- **Branch**: ${CIRCLE_BRANCH}" >> deployment-summary.md
            echo "- **Commit**: ${SHORT_SHA}" >> deployment-summary.md
            echo "- **Build Number**: ${CIRCLE_BUILD_NUM}" >> deployment-summary.md
            echo "" >> deployment-summary.md
            echo "### 📦 Pushed Images" >> deployment-summary.md
            echo "- ✅ \`${VERSIONED_IMAGE}\`" >> deployment-summary.md
            if [[ "${PUSH_LATEST}" == "true" ]]; then
              echo "- ✅ \`${LATEST_IMAGE}\`" >> deployment-summary.md
              echo "" >> deployment-summary.md
              echo "### 🎯 Deployment Ready" >> deployment-summary.md
              echo "This image is now available for production deployment!" >> deployment-summary.md
            else
              echo "" >> deployment-summary.md
              echo "### 🧪 Development Image" >> deployment-summary.md
              echo "This feature branch image is available for testing." >> deployment-summary.md
            fi
            echo "" >> deployment-summary.md
            echo "### 📊 Build Artifacts" >> deployment-summary.md
            echo "- ✅ Security scanned (Snyk)" >> deployment-summary.md
            echo "- ✅ Code quality checked (SonarQube)" >> deployment-summary.md
            echo "- ✅ Tests passed" >> deployment-summary.md
            echo "- ✅ Container security verified" >> deployment-summary.md
      
      - store_artifacts:
          path: deployment-summary.md
          destination: deployment-reports/deployment-summary.md

# ============================================================================
# WORKFLOWS
# ============================================================================
workflows:
  version: 2
  
  # Main CI/CD workflow
  ci-cd-pipeline:
    jobs:
      # Stage 1: Build and test foundation
      - build-and-test:
          filters:
            branches:
              only: /.*/
      
      # Stage 2: Security and quality analysis (parallel)
      - snyk-security-scan:
          context: dotnet-webapi-security
          requires:
            - build-and-test
          filters:
            branches:
              only: /.*/
      
      - sonarqube-scan:
          context: dotnet-webapi-security
          requires:
            - build-and-test
          filters:
            branches:
              only: /.*/
      
      # Stage 3: Docker build and scan
      - build-and-scan-docker-image:
          context: dotnet-webapi-security
          requires:
            - build-and-test
            - snyk-security-scan
            - sonarqube-scan
          filters:
            branches:
              only: /.*/
      
      # Stage 4: Deploy to registry using JFrog Orb commands (all branches for testing)
      - push-docker-image-jfrog:
          context: dotnet-webapi-security
          requires:
            - build-and-scan-docker-image
          filters:
            branches:
              only: /.*/ 
